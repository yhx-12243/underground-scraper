diff --git a/src/lib.rs b/src/lib.rs
index 7b9952a..373c3b2 100644
--- a/src/lib.rs
+++ b/src/lib.rs
@@ -535,7 +535,7 @@ impl CompactString {
     /// ```
     #[inline]
     pub fn as_bytes(&self) -> &[u8] {
-        &self.0.as_slice()[..self.len()]
+        self.0.as_slice()
     }
 
     // TODO: Implement a `try_as_mut_slice(...)` that will fail if it results in cloning?
diff --git a/src/repr/capacity.rs b/src/repr/capacity.rs
index 2bff6eb..9c67e18 100644
--- a/src/repr/capacity.rs
+++ b/src/repr/capacity.rs
@@ -16,6 +16,7 @@ const fn CAP_ON_HEAP_FLAG() -> [u8; USIZE_SIZE] {
 ///
 /// All bytes `255`, with the last being [`HEAP_MASK`], using the same amount of bytes as `usize`
 /// Example (64-bit): `[255, 255, 255, 255, 255, 255, 255, 254]`
+#[cfg(not(target_pointer_width = "64"))]
 const CAPACITY_IS_ON_THE_HEAP: [u8; USIZE_SIZE] = CAP_ON_HEAP_FLAG();
 
 // how many bytes we can use for capacity
@@ -101,7 +102,13 @@ impl Capacity {
     /// stored on the heap
     #[inline(always)]
     pub fn is_heap(&self) -> bool {
-        self.0 == CAPACITY_IS_ON_THE_HEAP
+        cfg_if::cfg_if! {
+            if #[cfg(target_pointer_width = "64")] {
+                false
+            } else {
+                self == CAPACITY_IS_ON_THE_HEAP
+            }
+        }
     }
 }
 
diff --git a/src/repr/mod.rs b/src/repr/mod.rs
index 52ec531..e7dc293 100644
--- a/src/repr/mod.rs
+++ b/src/repr/mod.rs
@@ -113,19 +113,6 @@ impl Repr {
         // Create a Repr with enough capacity for the entire buffer
         let mut repr = Repr::with_capacity(bytes_len);
 
-        // There's an edge case where the final byte of this buffer == `HEAP_MASK`, which is
-        // invalid UTF-8, but would result in us creating an inline variant, that identifies as
-        // a heap variant. If a user ever tried to reference the data at all, we'd incorrectly
-        // try and read data from an invalid memory address, causing undefined behavior.
-        if bytes_len == MAX_SIZE {
-            let last_byte = bytes[bytes_len - 1];
-            // If we hit the edge case, reserve additional space to make the repr becomes heap
-            // allocated, which prevents us from writing this last byte inline
-            if last_byte >= 0b11000000 {
-                repr.reserve(MAX_SIZE + 1);
-            }
-        }
-
         // SAFETY: The caller is responsible for making sure the provided buffer is UTF-8. This
         // invariant is documented in the public API
         let slice = repr.as_mut_buf();
