diff --git a/lib/grammers-client/src/types/iter_buffer.rs b/lib/grammers-client/src/types/iter_buffer.rs
index 4b98461..6f088ec 100644
--- a/lib/grammers-client/src/types/iter_buffer.rs
+++ b/lib/grammers-client/src/types/iter_buffer.rs
@@ -59,7 +59,7 @@ impl<R, T> IterBuffer<R, T> {
     ///
     /// Data does not need to be fetched if the limit is reached or the buffer is empty and the
     /// last chunk was reached.
-    pub(crate) fn next_raw(&mut self) -> Option<Result<Option<T>, InvocationError>> {
+    pub fn next_raw(&mut self) -> Option<Result<Option<T>, InvocationError>> {
         if self.limit_reached() || (self.buffer.is_empty() && self.last_chunk) {
             Some(Ok(None))
         } else {
@@ -82,7 +82,7 @@ impl<R, T> IterBuffer<R, T> {
     }
 
     /// Pop a buffered item from the queue, and increment the amount of items fetched (returned).
-    pub(crate) fn pop_item(&mut self) -> Option<T> {
+    pub fn pop_item(&mut self) -> Option<T> {
         if let Some(item) = self.buffer.pop_front() {
             self.fetched += 1;
             Some(item)
diff --git a/lib/grammers-client/src/types/message.rs b/lib/grammers-client/src/types/message.rs
index c7f53fd..7fe2a81 100644
--- a/lib/grammers-client/src/types/message.rs
+++ b/lib/grammers-client/src/types/message.rs
@@ -169,6 +169,10 @@ impl Message {
         }
     }
 
+    pub fn into_inner(self) -> tl::types::Message {
+        self.msg
+    }
+
     /// Whether the message is outgoing (i.e. you sent this message to some other chat) or
     /// incoming (i.e. someone else sent it to you or the chat).
     pub fn outgoing(&self) -> bool {
