diff --git a/lib/grammers-client/src/types/iter_buffer.rs b/lib/grammers-client/src/types/iter_buffer.rs
index 4b98461..6f088ec 100644
--- a/lib/grammers-client/src/types/iter_buffer.rs
+++ b/lib/grammers-client/src/types/iter_buffer.rs
@@ -59,7 +59,7 @@ impl<R, T> IterBuffer<R, T> {
     ///
     /// Data does not need to be fetched if the limit is reached or the buffer is empty and the
     /// last chunk was reached.
-    pub(crate) fn next_raw(&mut self) -> Option<Result<Option<T>, InvocationError>> {
+    pub fn next_raw(&mut self) -> Option<Result<Option<T>, InvocationError>> {
         if self.limit_reached() || (self.buffer.is_empty() && self.last_chunk) {
             Some(Ok(None))
         } else {
@@ -82,7 +82,7 @@ impl<R, T> IterBuffer<R, T> {
     }
 
     /// Pop a buffered item from the queue, and increment the amount of items fetched (returned).
-    pub(crate) fn pop_item(&mut self) -> Option<T> {
+    pub fn pop_item(&mut self) -> Option<T> {
         if let Some(item) = self.buffer.pop_front() {
             self.fetched += 1;
             Some(item)
diff --git a/lib/grammers-client/src/types/message.rs b/lib/grammers-client/src/types/message.rs
index c7f53fd..7fe2a81 100644
--- a/lib/grammers-client/src/types/message.rs
+++ b/lib/grammers-client/src/types/message.rs
@@ -169,6 +169,10 @@ impl Message {
         }
     }
 
+    pub fn into_inner(self) -> tl::types::Message {
+        self.msg
+    }
+
     /// Whether the message is outgoing (i.e. you sent this message to some other chat) or
     /// incoming (i.e. someone else sent it to you or the chat).
     pub fn outgoing(&self) -> bool {
diff --git a/lib/grammers-session/src/lib.rs b/lib/grammers-session/src/lib.rs
index 2a2b1bd..80d0af7 100644
--- a/lib/grammers-session/src/lib.rs
+++ b/lib/grammers-session/src/lib.rs
@@ -16,8 +16,8 @@ pub use chat::{ChatHashCache, PackedChat, PackedType};
 pub use generated::types::UpdateState;
 pub use generated::types::User;
 pub use generated::LAYER as VERSION;
-use generated::{enums, types};
-use grammers_tl_types::deserialize::Error as DeserializeError;
+pub use generated::{enums, types};
+pub use grammers_tl_types::deserialize::Error as DeserializeError;
 pub use message_box::{channel_id, PrematureEndReason};
 pub use message_box::{Gap, MessageBox};
 use std::fmt;
@@ -34,6 +34,14 @@ pub struct Session {
     session: Mutex<types::Session>,
 }
 
+impl From<types::Session> for Session {
+    fn from(session: types::Session) -> Self {
+        Self {
+            session: Mutex::new(session),
+        }
+    }
+}
+
 #[allow(clippy::new_without_default)]
 impl Session {
     pub fn new() -> Self {
@@ -148,6 +156,10 @@ impl Session {
             .map(|enums::User::User(user)| user.clone())
     }
 
+    pub fn get(&self) -> types::Session {
+        self.session.lock().unwrap_or_else(std::sync::PoisonError::into_inner).clone()
+    }
+
     pub fn get_state(&self) -> Option<UpdateState> {
         let session = self.session.lock().unwrap();
         let enums::UpdateState::State(state) = session.state.clone()?;
